@page "/game"
@rendermode InteractiveServer
@using KingOfTheHill
@using Microsoft.AspNetCore.SignalR.Client
@using Newtonsoft.Json
@using Newtonsoft.Json.Serialization
@using static KingOfTheHill.IGameProvider
@implements IAsyncDisposable
@inject NavigationManager NavigationManager

<div class="logo__backgorund"></div>

@if (_currentGame is not null && _currentGame.isStarted)
{
<div class="game__container">
    <div class="top__players">
        @foreach (var player in _currentGame.Players)
        {
            @if (player.Id != _currentPlayerId)
            {
                <div 
                    @onclick="(() => SelectPlayer(player))" 
                    class="player__block @(_selectedPlayer is not null && _selectedPlayer.Id == player.Id
                    ? "player__selected" : "")"
                >
                    <h4 class="player__name">@player.Name</h4>
                    <div class="player__avatar">üë®üèø‚Äçü¶Ω</div>
                    <div class="player__cards">
                        @foreach (var card in player.Deck)
                        {
                            <div class="card__back">
                                <img src="images/BackSide.png"/>
                            </div>
                        }
                    </div>
                    @if (_seeAllScore)
                    {
                        <div class="player__score">
                            –°—á—ë—Ç –∏–≥—Ä–æ–∫–∞: @player.Score
                        </div>
                    }
                </div>
            }
        }
    </div>

    <div class="player__hand">
        @foreach (var (card, i) in _currentPlayer!.Deck.Select((item, i) => (item, i)))
        {
            @if (card is PositiveCard pCard)
            {
                <button 
                    disabled="@(_currentGame.CurrentPlayer != _currentPlayerId)" 
                    @onclick="@(() => CardHandler(i))" 
                    class="hand__card @(_comboHand.Contains(i) ? "inHand": "")"
                >
                    <img src="images/Positive_@(pCard.Value).png"/>
                </button>
            } else if (card is NegativeCard nCard)
            {
                <button 
                    disabled="@(_currentGame.CurrentPlayer != _currentPlayerId)" 
                    @onclick="@(() => CardHandler(i))" 
                    class="hand__card @(_comboHand.Contains(i) ? "inHand": "")"
                >
                    <img src="images/Negative_@(nCard.Value).png"/>
                </button>
            } else if (card is SpecialCard sCard)
            {
                @if (sCard.Value == SpecialCommand.Silence)
                {
                    <button 
                        disabled="@(_currentGame.CurrentPlayer != _currentPlayerId)" 
                        @onclick="@(() => CardHandler(i))" class="hand__card 
                        @(_comboHand.Contains(i) ? "inHand": "")"
                    >
                        <img src="images/Block.png"/>
                    </button>
                } else if (sCard.Value == SpecialCommand.ChangeMove)
                {
                    <button 
                        disabled="@(_currentGame.CurrentPlayer != _currentPlayerId)" 
                        @onclick="@(() => CardHandler(i))" 
                        class="hand__card @(_comboHand.Contains(i) ? "inHand": "")"
                    >
                        <img src="images/Reverse.png"/>
                    </button>
                }
            } else if (card is BonusCard bCard)
            {
                <button 
                    disabled="@(_currentGame.CurrentPlayer != _currentPlayerId)" 
                    @onclick="@(() => CardHandler(i))" 
                    class="hand__card @(_comboHand.Contains(i) ? "inHand": "")"
                >
                    <img src="images/Bonus.png"/>
                </button>
            }
        }
    </div>
    <div class="playButton__card">
        <button @onclick="@(() => DoMovePlayer())" disabled="@(_comboHand.Count == 0 || _comboHand.Count == 2)">
            @(_comboHand.Count <= 1 ? "–†–∞–∑—ã–≥—Ä–∞—Ç—å –∫–∞—Ä—Ç—É" : "–†–∞–∑—ã–≥—Ä–∞—Ç—å –∫–∞—Ä—Ç—ã")
        </button>
        @if (_warning)
        {
            <p>–í—ã –¥–æ–ª–∂–Ω—ã —É–∫–∞–∑–∞—Ç—å –Ω–∞ –∫–æ–≥–æ –ø—Ä–∏–º–µ–Ω–∏—Ç—å –¥–∞–Ω–Ω—É—é –∫–∞—Ä—Ç—É –∏–ª–∏ –∫–æ–º–±–∏–Ω–∞—Ü–∏—é</p>
        }
        @if (_isSkipped)
        {
            <p>–í–∞–º –∑–∞–ø—Ä–µ—Ç–∏–ª–∏ —Ö–æ–¥–∏—Ç—å!ü§¨</p>
        }
        @if (_isNotComb)
        {
            <p>–ù–µ –ø–æ–¥—Ö–æ–¥—è—â–∞—è –∫–æ–º–±–∏–Ω–∞—Ü–∏—è</p>
        }
    </div>
    @if (_currentPlayer.HasCombo)
    {
        <div class="combo__menu">
            <div class="combo__list">
                <div @onclick='(() => ComboHandler("SeeScore"))' class="combo__seeScore @(_cardComb == "SeeScore" ? _cardComb : "")">
                    <img src="images/SeeScore.png"/>
                </div>
            </div>

            @if (_seeInformation)
            {
                <div class="informationCombo">
                    <p>@_informationCombo</p>
                </div>
                <button @onclick="(() => ComboActionActivate())">–ê–∫—Ç–∏–≤–∏—Ä–æ–≤–∞—Ç—å</button>
            }
        </div>
    }
    @if (_currentPlayer.HasCombo || _winner != null)
    {
        <div class="overlay"></div>
    }
    @if (_winner != null)
    {
        <div class="winner__block">
            <div class="winner__message">
                <p>@(_currentPlayer.Id == _winner.Id ? "–í—ã –≤—ã–∏–≥—Ä–∞–ª–∏!üëæ" : $"–í—ã–∏–≥—Ä–∞–ª –∏–≥—Ä–æ–∫: {_winner.Name}ü§¢")</p>
            </div>
            <div class="exit__block">
                <button class="exit__button" @onclick="@(() => LeaveLobby())">–í—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã</button>
            </div>
        </div>
    }
    <div class="player__move">
        @(_currentGame.CurrentPlayer == _currentPlayerId 
        ? "–°–µ–π—á–∞—Å —Ö–æ–¥–∏—Ç–µ –í—ã"
        : $"–•–æ–¥ –∏–≥—Ä–æ–∫–∞: {_currentGame.Players.Find(p => p.Id == _currentGame.CurrentPlayer)!.Name}")
    </div>
    <div class="bottom__panel">
        <div class="haveCombo__panel">–ï—Å—Ç—å –ª–∏ —É –≤–∞—Å –∫–æ–º–±–æ: @(_currentPlayer.HasCombo ? "–î–∞!" : "–ù–µ—Çüò¢")</div>

        <div class="score__panel">
            <p>–í–∞—à —Å—á—ë—Ç: <span>@_currentPlayer.Score</span></p>
        </div>
    </div>
</div>
} else
{
    @if (_isLobbyVisible)
    {
        <div class="overlay"></div>
    }

    <div class="lobby__container">
        <div class="input__block">
            <input
                id="username"
                name="Username" 
                disabled=@(_currentGame is not null) 
                placeholder="–í–≤–µ–¥–∏—Ç–µ –í–∞—à –Ω–∏–∫–Ω–µ–π–º" 
                @bind="@Username"
            />
        </div>

        <div class="lobbies">
            <div class="lobbies__title">
                <h1>–°–ø–∏—Å–æ–∫ –õ–æ–±–±–∏</h1>
            </div>
            <div class="lobbies__list">
                @if (Lobbies.Count != 0)
                {
                    <div class="list__lobby">
                    @foreach (var (item, i) in Lobbies.Select((value, index) => (value, index)))
                    {
                            <div>
                                <p>@(i + 1)</p>
                                <p>@(item.Value.Players.Count)/4</p>
                                <p>@item.Value.isStarted</p>
                                <button 
                                    disabled=@(string.IsNullOrWhiteSpace(Username) || _currentGame is not null || item.Value.Players.Count == 4 || item.Value.isStarted) 
                                    @onclick="@(() => JoinLobby(item.Value.GameID))">
                                        –ü–æ–¥–∫–ª—é—á–∏—Ç—å—Å—è
                                </button>
                            </div>
                    }
                    </div>
                }
                <div class="button__lobby">
                    <button disabled=@(string.IsNullOrWhiteSpace(Username)) class="list__createButton" @onclick="@(() => CreateLobby())">–°–æ–∑–¥–∞—Ç—å –ª–æ–±–±–∏</button>
                    <button class="list__refreshButton" @onclick="@(() => RefreshLobbies())">–û–±–Ω–æ–≤–∏—Ç—å —Å–ø–∏—Å–æ–∫ –ª–æ–±–±–∏</button>
                </div>
            @if (_isLobbyVisible)
            {
                <div class="list__menu">
                    <div class="players__list">
                        @for (int i = 0; i < _currentGame!.Players.Count; i++)
                        {
                            <div>
                                <p>@(i + 1)</p>
                                <p>
                                    @_currentGame!.Players[@i].Name;
                                </p>
                            </div>
                        }
                    </div>
                    <div class="menu__other">
                        <div class="menu__timer @(_isTimerVisible ? "visible": "hidden")">@displayTime</div>
                        <button class="exit__button" @onclick="@(() => LeaveLobby())">–í—ã–π—Ç–∏ –∏–∑ –∏–≥—Ä—ã</button>
                    </div>
                </div>
            }
            </div>
        </div>
    </div>
}



@code
{
    private string? Username;
    private Dictionary<Guid, Game> Lobbies = [];
    private HubConnection? _hubConnection;
    private bool _isLobbyVisible = false;
    private bool _isTimerVisible = false;
    private Game? _currentGame;
    private int displayTime = 60;
    private Guid? _currentPlayerId;
    private Player? _currentPlayer;
    private List<int> _comboHand = [];
    private Player? _selectedPlayer;
    private bool _warning = false;
    private bool _isSkipped = false;
    private bool _isNotComb = false;
    private string _informationCombo = "";
    private bool _seeInformation = false;
    private bool _seeAllScore = false;
    private string _cardComb = "";
    private Player? _winner;

    protected override async Task OnInitializedAsync()
    {
        _hubConnection = new HubConnectionBuilder()
            .WithUrl(NavigationManager.ToAbsoluteUri("/gamehub"))
            .AddNewtonsoftJsonProtocol(options =>
            {
                options.PayloadSerializerSettings = new JsonSerializerSettings
                {
                    // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏–∏ Newtonsoft.Json
                    NullValueHandling = NullValueHandling.Ignore,
                    Formatting = Formatting.None,
                    ReferenceLoopHandling = ReferenceLoopHandling.Serialize,
                    TypeNameHandling = TypeNameHandling.Auto, // –î–ª—è –ø–æ–¥–¥–µ—Ä–∂–∫–∏ –ø–æ–ª–∏–º–æ—Ä—Ñ–∏–∑–º–∞
                    ContractResolver = new DefaultContractResolver
                    {
                        NamingStrategy = new CamelCaseNamingStrategy()
                    }
                };
            })
            .Build();


        try
        {
            await _hubConnection.StartAsync();
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exeption on client side on OnInitializedAsync", ex);
        }

        _hubConnection.On<Game>("JoinGameLobby", (game) =>
        {
            _isLobbyVisible = true;
            _currentGame = game;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Game>("GameCreated", (game) =>
        {
            Lobbies?.Add(game.GameID, game);
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<int>("UpdateTimer", (seconds) =>
        {
            _isTimerVisible = true;
            displayTime = seconds;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On("TimerWasStarted", () =>
        {
            _isTimerVisible = true;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On("TimerWasStopped", () =>
        {
            displayTime = 60;
            _isTimerVisible = false;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Game>("StartGame", (game) =>
        {
            _currentGame = game;
            _currentPlayer = _currentGame.Players.Find(p => p.Id == _currentPlayerId);
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Dictionary<Guid, Game>>("RefreshGamesList", (Dictionary<Guid, Game> _games) =>
        {
            Lobbies = _games;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Guid, Game>("RenderAfterJoinUser", (gameId, game) => 
        {
            Lobbies[gameId] = game;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On("ToMainPage", () => 
        {
            _isLobbyVisible = false;
            _currentGame = null;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Game>("UpdateAfterLeave", game =>
        {
            _currentGame = game;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Guid>("DeleteGameFromLobby", gameId =>
        {
            Lobbies?.Remove(gameId);
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Player>("ChangePlayerState", player => 
        {
            if (player.Id == _currentPlayerId)
                _currentPlayer = player;
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Game>("ChangeGameState", game => 
        {
            _currentGame = game;
            _currentPlayer = game.Players.Find(p => p.Id == _currentPlayerId);
            if (_currentPlayer!.isSkipTurn)
            {
                _isSkipped = true;
                try
                {
                    InvokeAsync(async () => await _hubConnection.SendAsync("EndMove"));
                } catch (Exception ex)
                {
                    Console.WriteLine("Exeption on client side on ChangeGameState", ex);
                }
            }
            InvokeAsync(StateHasChanged);
        });

        _hubConnection.On<Game>("FinishGame", game => 
        {
            _winner = game.Players.Find(p => p.Score >= game.MaxScore);
            InvokeAsync(StateHasChanged);
        });
    }

    private async Task RefreshLobbies()
    {
        if (_hubConnection is null) return;

        try
        {
            await _hubConnection.SendAsync("GetActiveGames");
        } catch (Exception ex)
        {
            Console.WriteLine("Exeption on client side on RefreshLobbies", ex);
        }
    }

    private async Task JoinLobby(Guid gameId)
    {
        if (_hubConnection is null) return;

        _currentPlayerId = Guid.NewGuid();

        try
        {
            await _hubConnection.SendAsync("JoinGameAsync", _currentPlayerId, Username, gameId);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exeption on client side on JoinLobby", ex);
        }
    }

    private async Task CreateLobby()
    {
        if (_hubConnection is null) return;

        _currentPlayerId = Guid.NewGuid();

        try
        {
            await _hubConnection.SendAsync("CreateGameAsync", _currentPlayerId, Username);
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exeption on client side on CreateLobby", ex);
        }
    }


    private async Task LeaveLobby()
    {
        if (_hubConnection is null) return;

        _currentGame.isStarted = false;
        _winner = null;
        _currentPlayer = null;

        try
        {
            await _hubConnection.SendAsync("LeaveGameAsync", _currentGame.GameID);
        }

        catch (Exception ex)
        {
            Console.WriteLine("Exeption on client side on LeaveLobby", ex);
        }
    }

    private void CardHandler(int cardIndex)
    {
        _seeAllScore = false;
        _warning = false;
        _isSkipped = false;
        _isNotComb = false;
        if (_comboHand.Contains(cardIndex))
            _comboHand.Remove(cardIndex);
        else if (_comboHand.Count == 3)
            return;
        else
            _comboHand.Add(cardIndex);
    }

    private void SelectPlayer(Player player)
    {
        _warning = false;
        _isSkipped = false;
        _isNotComb = false;
        if (_currentPlayerId != _currentGame!.CurrentPlayer)
            return;
        if (_selectedPlayer is not null && _selectedPlayer.Id == player.Id)
            _selectedPlayer = null;
        else
            _selectedPlayer = player;
    }
    private async Task DoMovePlayer()
    {
        if (_hubConnection is null) return;

        if (_comboHand.Count == 1)
        {
            int cardIndex = _comboHand[0];
            ICard card = _currentPlayer!.Deck[cardIndex];
            if (card is SpecialCard sCard)
            {
                try
                {
                    await _hubConnection.SendAsync("UseCardAttachedToGame", cardIndex);
                } catch (Exception ex)
                {
                    Console.WriteLine("Exeption on client side on DoMovePlayer UseCardAttachedToGame", ex);
                }
            } else
            {
                if (_selectedPlayer is null && card is NegativeCard)
                {
                    _warning = true;
                    return;
                } else if (_selectedPlayer is not null && card is not NegativeCard)
                    _selectedPlayer = null;
                try
                {
                    await _hubConnection.SendAsync("UseCardAttachedToPlayer", cardIndex, _selectedPlayer);
                } catch (Exception ex)
                {
                    Console.WriteLine("Exeption on client side on DoMovePlayer UseCardAttachedToPlayer", ex);
                }
                _selectedPlayer = null;
            }
            _comboHand.Remove(cardIndex);
        } else if (_comboHand.Count == 3)
        {
            List<ICard> inHand = [];
            for (int i = 0; i < _comboHand.Count; i++)
                inHand.Add(_currentPlayer!.Deck[_comboHand[i]]);

            bool allPositive = inHand.All(card => card is PositiveCard);
            bool allNegative = inHand.All(card => card is NegativeCard);

            if (!allPositive && !allNegative)
            {
                _isNotComb = true;
                return;
            }

            if (allPositive)
            {
                var positiveCards = inHand.Cast<PositiveCard>().ToArray();
                if (!positiveCards.All(c => c.Value == positiveCards[0].Value))
                {
                    _isNotComb = true;
                    return;
                }
            }

            if (allNegative)
            {
                var negativeCards = inHand.Cast<NegativeCard>().ToArray();
                if (!negativeCards.All(c => c.Value == negativeCards[0].Value))
                {
                    _isNotComb = true;
                    return;
                }

                if (_selectedPlayer == null)
                {
                    _warning = true;
                    return;
                }
            }

            try
            {
                await _hubConnection.SendAsync("UseComboAttachedToPlayer", _comboHand, _selectedPlayer);
            } catch (Exception ex)
            {
                Console.WriteLine("Exeption on client side on DoMovePlayer UseComboAttachedToPlayer", ex);
            }
            _comboHand = [];
        }
    }

    private void ComboHandler(string action)
    {
        if (_seeInformation)
        {
            _seeInformation = false;
            _cardComb = "";
            return;
        }

        if (action == "SeeScore")
        {
            _informationCombo = "–ü–æ–∑–≤–æ–ª—è–µ—Ç —É–≤–∏–¥–µ—Ç—å —Å—á—ë—Ç –≤—Å–µ—Ö –∏–≥—Ä–æ–∫–æ–≤. –î–µ–π—Å—Ç–≤—É–µ—Ç –¥–æ —Å–ª–µ–¥—É—é—â–µ–≥–æ –í–∞—à–µ–≥–æ —Ö–æ–¥–∞";
            _seeInformation = true;
            _cardComb = action;
        }
    }

    public async Task ComboActionActivate()
    {
        if (_hubConnection is null) return;

        _seeAllScore = true;

        try
        {
            await _hubConnection.SendAsync("EndMove");
        } catch (Exception ex)
        {
            Console.WriteLine("Exeption on client side on ComboActionActivate EndMove", ex);
        }
    }

    public async ValueTask DisposeAsync()
    {
        if (_hubConnection == null) return;

        Console.WriteLine("Hello From DisposeAsync on Client Side");

        try
        {
            await _hubConnection.StopAsync();
        }
        finally
        {
            await _hubConnection.DisposeAsync();
        }
    }
}